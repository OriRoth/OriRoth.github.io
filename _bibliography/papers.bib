---
---

@article{Roth:2023,
    author = {Roth, Ori and Gil, Yossi},
    title = {Fluent APIs in Functional Languages},
    year = {2023},
    issue_date = {April 2023},
    publisher = {Association for Computing Machinery},
    address = {New York, NY, USA},
    volume = {7},
    number = {OOPSLA1},
    url = {https://doi.org/10.1145/3586057},
    doi = {10.1145/3586057},
    abstract = {Fluent API is an object-oriented pattern for elegant APIs and embedded DSLs. A smart fluent API can enforce the API protocol or DSL syntax at compile time. Since fluent API implementations typically rely on overloading function names, they are hard to realize in functional programming languages. This work shows how functional fluent APIs can be implemented in the absence of name overloading, by relying on parametric polymorphism and Hindley-Milner type inference. The implementation supports fluent API protocols in the regular- and deterministic context-free language classes, and even beyond.},
    journal = {Proc. ACM Program. Lang.},
    month = {apr},
    articleno = {105},
    numpages = {26},
    keywords = {embedded DSLs, fluent API, API protocols},
	abbr={OOPSLA2023},
	selected={true},
	pdf={https://dl.acm.org/doi/pdf/10.1145/3586057},
}


@misc{Roth:2022,
	doi = {10.48550/ARXIV.2208.14755},
	url = {https://arxiv.org/abs/2208.14755},
	author = {Roth, Ori},
	keywords = {Programming Languages (cs.PL), FOS: Computer and information sciences, FOS: Computer and information sciences},
	title = {Python Type Hints are Turing Complete},
	publisher = {arXiv},
	year = {2022},
	copyright = {Creative Commons Attribution 4.0 International},
	abstract={Grigore showed that Java generics are Turing complete by describing a reduction from Turing machines to Java subtyping. We apply Grigore's algorithm to Python type hints and deduce that they are Turing complete. In addition, we present an alternative reduction in which the Turing machines are simulated in real time, resulting in significantly lower compilation times. Our work is accompanied by a Python implementation of both reductions that compiles Turing machines into Python subtyping machines.},
	selected={true},
	pdf={https://arxiv.org/pdf/2208.14755},
	abbr={arXiv},
}

@article{Roth:2021,
	author = {Roth, Ori},
	title = {Study of the Subtyping Machine of Nominal Subtyping with Variance},
	year = {2021},
	issue_date = {October 2021},
	publisher = {Association for Computing Machinery},
	address = {New York, NY, USA},
	volume = {5},
	number = {OOPSLA},
	url = {https://doi.org/10.1145/3485514},
	doi = {10.1145/3485514},
	journal = {Proc. ACM Program. Lang.},
	month = {oct},
	articleno = {137},
	numpages = {27},
	keywords = {metaprogramming, DSL, fluent API, subtyping, variance},
	abstract = {This is a study of the computing power of the subtyping machine behind Kennedy and Pierce's nominal subtyping with variance. We depict the lattice of fragments of Kennedy and Pierce's type system and characterize their computing power in terms of regular, context-free, deterministic, and non-deterministic tree languages. Based on the theory, we present Treetop---a generator of C# implementations of subtyping machines. The software artifact constitutes the first feasible (yet POC) fluent API generator to support context-free API protocols in a decidable type system fragment.},
	abbr={OOPSLA2021},
	selected={true},
	pdf={https://dl.acm.org/doi/pdf/10.1145/3485514},
}

@InProceedings{Gil:2019,
	author =	{Yossi Gil and Ori Roth},
	title =	{{Fling - A Fluent API Generator}},
	booktitle =	{33rd European Conference on Object-Oriented Programming (ECOOP 2019)},
	pages =	{13:1--13:25},
	series =	{Leibniz International Proceedings in Informatics (LIPIcs)},
	ISBN =	{978-3-95977-111-5},
	ISSN =	{1868-8969},
	year =	{2019},
	volume =	{134},
	editor =	{Alastair F. Donaldson},
	publisher =	{Schloss Dagstuhl--Leibniz-Zentrum fuer Informatik},
	address =	{Dagstuhl, Germany},
	URL =		{http://drops.dagstuhl.de/opus/volltexte/2019/10805},
	URN =		{urn:nbn:de:0030-drops-108053},
	doi =		{10.4230/LIPIcs.ECOOP.2019.13},
	annote =	{Keywords: fluent API, type system, compilation, code generation},
	abstract = {We present the first general and practical solution of the fluent API problem - an algorithm, that given a deterministic language (equivalently, LR(k), k >= 0 language) encodes it in an unbounded parametric polymorphism type system employing only a polynomial number of types. The theoretical result is accompanied by an actual tool Fling - a fluent API compiler-compiler in the venue of YACC, tailored for embedding DSLs in Java.},
	abbr={ECOOP},
	selected={true},
	pdf={https://drops.dagstuhl.de/opus/volltexte/2019/10805/pdf/LIPIcs-ECOOP-2019-13.pdf},
}

@INPROCEEDINGS{Gil:2017b,
	author={Gil, Yossi and Ma'ayan, Dor and Shalmon, Niv and Rachmiel, Raviv and Roth, Ori},
	booktitle={2017 IEEE Working Conference on Software Visualization (VISSOFT)},
	title={Syntactic Zoom-Out / Zoom-In Code with the Athenizer},
	year={2017},
	pages={124-128},
	doi={10.1109/VISSOFT.2017.26},
	abstract={Care and great effort are often taken to dress program code of libraries, just as model implementations, in its most presentable form, which includes adherence to strict coding standards, careful selection of identifiers, avoiding unnecessary constructs, etc. However, a presentable dress is not a janitor's uniform and is often inferior to the more lax working outfit.The spartanizer is a tool that brings Java code into a canonical, short form. Trying to say the most with the fewest words. In contrast, the athenizer is a tool that expands the code, placing it in a more maintainable form, using plenty of auxiliary variables, many potential locations for breakpoints and for change.The tool reported on here allows developers to interactively use their joystick and its buttons for code navigation, and in particular for zooming-in into the code (athenizing) and zooming-out of it (spartanizing).},
	abbr={VISSOFT},
	selected={false},
}

@article{Gil:2017,
	author = {Gil, Yossi and Marcovitch, Ori and Orru, Matteo and Roth, Ori},
	doi = {10.25046/aj0203211},
	journal = {Advances in Science, Technology and Engineering Systems Journal},
	keywords = {programming languages},
	number = {3},
	pages = {1711--1726},
	title = {Pluggable Controllers and {Nano-Patterns} in {Java} with {Lola}},
	url = {https://astesj.com/v02/i03/p211/},
	volume = {2},
	year = {2017},
	abstract={
Pluggable controllers are a different way to design control constructors such as if, while, do, switch, and operators such as short circuit con-junction (&&) and the “?.” operator of the Swift programming language. Adoption of pluggable controllers enables the final user to modify and extend the control flow constructs (if, while, etc.) of an underlying programming language, the same way they can do if they implement functions such as printf and class String in a standard library.
In modular, pluggable controller based language design, beside core control constructors, there are others, defined in standard libraries, with the purpose of augmenting and enriching the language. These pluggable controllers are extensible and replaceable. Being less intertwined in the main language, control constructor libraries can evolve independently from it, and their releases do not mandate new language releases.
We illustrate the implementation of pluggable controllers using Lola, a powerful language-independent preprocessor and macro language. We demonstrate the introduction of new pluggable controllers with two case studies. The implementation of a Java stenography based on prevalent Java idioms, called “nano-patterns” or nanos, and the introduction in Java of new code constructs inspired by the Mathematica language’s commands.},
	abbr={ASTESJ},
	selected={false},
	pdf={https://www.astesj.com/?smd_process_download=1&download_id=2933},
}
